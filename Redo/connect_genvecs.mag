/* This program connects generating vectors of monodromy groups to the
      corresponding generators on the abstract groups pages.
   A list of [passport_label, connected_genvecs] is printed to a json file.
*/

/* Set the variable gxx below to the desired genus and also replace gxx in
   the string for the input file */
gxx:=3;

/* Input file */
load "SupplementaryFiles/BreuerRaw/g03";



if gxx lt 10 then
   genus_str := "0" cat IntegerToString(gxx);
else
   genus_str := IntegerToString(gxx);
end if;

/* Output file */
output_file := Sprintf("g%o_connected_genvecs.json", genus_str);

output_str := "[ ";


/* load gps_decode, a list (generated by a Python script) containing
      data from the groups db needed to construct groups in magma */
load "gps_decode.mag";

/* load RepresentativesEpimorphisms  */
load "genvectors.mag";

/* load PermRep */
load "ries_helper_fn.mag";


/* Create associative array of groups data, indexed by label, for
   quick accessing */
db_data := AssociativeArray();
for gp in gps_decode do
   gp_label := gp[1];
   db_data[gp_label] := [* gp[2], gp[3], gp[4], gp[5], gp[6] *];
end for;


/* Iterate over Ldata to compute generating vectors and connect with the
      generators on the abstract groups pages */
for ell in Ldata do
    sign := ell[1];
    order := ell[2,1];
    counter := ell[2,2];

    Grp := SmallGroup(order, counter);

    label := Sprintf("%o.%o", order, counter);

    try
        data := db_data[label];
    catch e
	printf "%o is not in the groups db\n", label;
        continue;
    end try;

    perm_gens := data[5];
    if Type(perm_gens) eq MonStgElt and perm_gens eq "error" then 
       printf "perm_gens not available for %o\n", label;
       continue;
    end if;

    /* Corresponding permutation group created from the SmallGroup */
    perm_group_mon := PermRep(Grp);

    /* Compute generating vectors */
    recs := RepresentativesEpimorphisms(sign, perm_group_mon);

    sign_str := IntegerToString(sign[1]);
    for i in [2..#sign] do
        sign_str := sign_str cat "." cat IntegerToString(sign[i]);
    end for;

    passport_label := Sprintf("%o.%o-%o.%o", gxx, IntegerToString(order),\
                                         IntegerToString(counter), sign_str);

    /* Group is solvable */
    if Type(perm_gens) eq MonStgElt and perm_gens eq "solvable" then
    
       /* Get the PC group decoded from the pc_code */
       pc_code := data[1];
       pc_group := SmallGroupDecoding(pc_code, order);

       ngens := data[2];
       if ngens ne NumberOfGenerators(pc_group) then
	  message := Sprintf("Number of generators in PC group does not" cat \
                             " match ngens in groups db: %o", [order,counter]);
          error message;
       end if;

       fp_group, fp_to_pc := FPGroup(pc_group); 
       pc_to_fp := Inverse(fp_to_pc);

       /* Simplify the generators and relations from the PC group, preserving
          the generators in gens_used */
       gens_used := data[3];
       G, fp_to_G := Simplify(fp_group : Preserve := gens_used);

       /* G is an FP group, so it cannot be passed to IsIsomorphic.
          Instead, create perm_to_pc, an isomorphism from the monodromy group to the
          decoded PC group. Then compose all the isomorphisms. */
       bool, perm_to_pc := IsIsomorphic(perm_group_mon, pc_group);
       iso := perm_to_pc * pc_to_fp * fp_to_G;

    /* Group is unsolvable */
    else

       degree := data[4];
       group_str := Sprintf("PermutationGroup<%o|%o>", degree, perm_gens);
       perm_group_rep := eval group_str;

       bool, iso := IsIsomorphic(perm_group_mon, perm_group_rep);

    end if;

    /* Iterate over the records to form passport_label, connected_genvec pairs */
    suffix := 1;
    for i in [1..#recs] do
       /* lists of conjugacy classes already lexicographically sorted? */
       pp_label := Sprintf("\"%o.%o\"", passport_label, suffix);
       genvec := recs[i]`genimages;
       connected_genvec := [];
       for gen in genvec do
          Append(~connected_genvec, Sprintf("\"%o\"", iso(gen)));
       end for;
       pair_str := Sprintf("[%o, %o],\n", pp_label, connected_genvec);
       output_str := output_str cat pair_str;
       suffix +:= 1;
    end for;
end for;

output_str := Substring(output_str, 1, #output_str-2) cat "]";

PrintFile(output_file, output_str);

